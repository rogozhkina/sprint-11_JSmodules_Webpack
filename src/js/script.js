(function () {
  const domRootNode = document.querySelector(".root");
  const domEditButton = document.querySelector(".user-info__button_edit");
  const domAddButton = document.querySelector(".user-info__button_add");
  const domCardListContainer = document.querySelector(".places-list");

  const errorEmptyField = "Это обязательное поле";
  const errorWrongLength = "Должно быть от 2 до 30 символов";
  const errorWrongLink = "Это не ссылка";

  const api = new Api({
    baseUrl: "https://praktikum.tk/cohort11",
    headers: {
      authorization: "098deaea-e99e-492d-906f-622aa2508f6d",
      "Content-Type": "application/json",
    },
  });

  const userInfo = new UserInfo(
    ".user-info__name",
    ".user-info__job",
    ".user-info__photo"
  );

  const cardList = new CardList(domCardListContainer, (cardData) => {
    return (newCard = new Card(cardData));
  });

  const formAdd = new FormCard(
    cardList,
    [
      new TextInput(
        "Название",
        "cardname",
        "text",
        new InputValidator(2, 30, errorEmptyField, errorWrongLength)
      ),
      new TextInput(
        "Ссылка на картинку",
        "link",
        "text",
        new URLValidator(errorEmptyField, errorWrongLink)
      ),
    ],
    new Button("+", ["popup__button"], "popup__button_disabled"),
    (tagElement, submit, inputs) => {
      return new FormValidator(tagElement, submit, inputs);
    },
    ["popup__form"]
  );
  const popupAdd = new Popup("Новое место", formAdd);

  const formEdit = new FormUser(
    userInfo,
    [
      new TextInput(
        "Имя",
        "username",
        "text",
        new InputValidator(2, 30, errorEmptyField, errorWrongLength)
      ),
      new TextInput(
        "О себе",
        "job",
        "text",
        new InputValidator(2, 30, errorEmptyField, errorWrongLength)
      ),
    ],
    new Button(
      "Сохранить",
      ["popup__button", "popup__button_edit"],
      "popup__button_disabled"
    ),
    (tagElement, submit, inputs) => {
      return new FormValidator(tagElement, submit, inputs);
    },
    ["popup__form"]
  );
  const popupUser = new Popup("Редактировать профиль", formEdit);

  const largeImage = new LargeImage();
  const popupImage = new PopupImage(largeImage);

  const page = new PlacesPage(
    api,
    domRootNode,
    domEditButton,
    domAddButton,
    cardList,
    userInfo,
    popupAdd,
    popupUser,
    formEdit,
    popupImage,
    largeImage
  );

  page.render();
})();

/*REVIEW. Резюме.
Над проектом хорошо потрудились, его продумывали. Молодец!

Но, кое-что не учтено при работе с сервером.

Что надо исправить.

1. + Методу this._api.updateUserInfo как параметры надо передавать значения полей формы, которые только что ввёл
пользователь (подробный комментарий в файле placespage.js).

2. + В этом же методе this._api.updateUserInfo нужен третий параметр коллбэк success, в котором должна быть обработка ответа
от сервера в случае успешности запроса  (подробный комментарий в файле placespage.js).



___________________________________________________________________________________________________________________________________________________
REVIEW2. Резюме2.

Вы, наверное изучали React - мне видится использование принципов этой библиотеки в Вашем коде.
Это хорошо, React-продвинутая библиотека js. Если не изучали - поизучайте, он, наверное, для Вас будет понятен, хотя он довольно труден для понимания
сначала.

Всё-таки форма профиля у Вас закрывается раньше, чем приходит ответ от сервера, а должна закрыться только после прихода успешного ответа и
заполнения элементов страницы информацией (не раньше).
Если же придёт неуспешный ответ (информация на сервере не сохранилась) форма вообще не должна закрываться - пользователь может выйти из формы по крестику,
когда Вы ему сообщите о неуспешности, или попробовать ещё раз.
Вы написали, что закрытие формы происходит по подписке popup на событие формы, но по подписке на какое событие? Если на событие сабмита, то форма и
закроется слишком рано, когда только пользователь нажмёт кнопку сохранить. Ответ от сервера придёт гораздо позже, и, чтобы закрыть форму только, когда
ответ придёт и обработается, надо и подписываться на событие прихода ответа, а не сабмита. А становится известным, что ответ пришёл только в методе
then обработки ответа сервера и больше нигде. Поэтому нужно, чтобы команда закрытия формы профиля выполнилась в методе then, где у Вас сейчас стоит
вызов вашего коллбэка fSuccess(res). Где бы Вы ни делали вызов метода закрытия в другом месте кода, закрытие произойдет раньше, чем это бы произошло
в методе then обработки ответа. Так работает асинхронность ответа сервера.
Асинхронность означает, что все команды проекта, находящиеся вне метода then обработки ответа от сервера, выполнятся (которые могут выполниться
в это время по логике проекта) раньше, чем придёт ответ от сервера. И, если Вы хотите, чтобы какие-то команды не выполнялись до прихода ответа,
их нужно поместить в методы then, или catch обработки ответа сервера.

Поэтому команду закрытия формы профиля нужно поместить последней инструкцией в тот же коллбэк fSuccess.

Но, вообще-то я рекомендую Вам сделать другую структуру методов Api, чтобы они были независимы от каких-либо коллбэков, то есть лучше, чтобы методы
Api только делали запрос и возвращали ответ от сервера (успешный или неуспешный), обработка же этого ответа происходила вне класса  Api.
Вот общая структура такого метода:

methodApi = (...) => {
return fetch(`...`, {
 ...
})
.then(res => {
  if (!res.ok) {
    return Promise.reject(res.status);
  } else {
    return res.json();
  }
})
}
То есть,
как Вы видете из приведённой структуры методов, они только возвращают ответ от сервера в виде объекта-промиса - успешного ответа, или объекта ошибки
(обратите внимание, что нужна инструкция return перед fetch), обработку этого ответа они не содержат.
Методы Api должны вызываться в других файлах Вашего проекта, и возвращаемый ими объект должен обрабатываться в методе .then, прикреплённом
к вызываемому методу Api, силами методов других классов. Блок .catch должен быть последним в цепочке (после метода .then, в котором обрабатывается ответ).

То есть структура вызова преобразованного метода api и обработки результата ответа должна быть такой:

api.methodApi(параметры).then(обработка ответа силами методов других классов).catch(...);

Не хочу задерживать Вашу работу, но, уверена, что Вы, как человек вдумчивый, ещё раз вникнув в особенности работы с сервером, которые я описала выше,
поместите команду закрытия формы профиля в нужном месте, и, возможно придёте к выводу, что другая структура методов Api (приведённая мной) более
универсальна и будете использовать её в своём проекте. А, вообще, Вы, конечно, молодец!

Рекомендую прочитать https://learn.javascript.ru/promise-error-handling "Промисы: обработка ошибок", которая, возможно, также поможет ещё лучше разобраться
в непростых вопросах работы с сервером.

Работа принимается.

Желаю дальнейших успехов в обучении!

*/
